"use strict";(self.webpackChunkwayang_website=self.webpackChunkwayang_website||[]).push([[5539],{1642:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var t=a(5893),i=a(1151);const o={slug:"wayang-python-api",title:"Pywayang - Apache Wayang's Python API",authors:["juripetersen"],tags:["wayang","python"]},s="Pywayang - Apache Wayang's Python API",r={permalink:"/blog/wayang-python-api",source:"@site/blog/2024-04-09-python-api.md",title:"Pywayang - Apache Wayang's Python API",description:"In the vast landscape of data processing, efficiency and flexibility are",date:"2024-04-09T00:00:00.000Z",formattedDate:"April 9, 2024",tags:[{label:"wayang",permalink:"/blog/tags/wayang"},{label:"python",permalink:"/blog/tags/python"}],readingTime:3.815,hasTruncateMarker:!0,authors:[{name:"Juri Petersen",title:"Apache Committer",url:"https://github.com/juripetersen",imageURL:"https://avatars.githubusercontent.com/u/43411515?v=4",key:"juripetersen"}],frontMatter:{slug:"wayang-python-api",title:"Pywayang - Apache Wayang's Python API",authors:["juripetersen"],tags:["wayang","python"]},unlisted:!1,prevItem:{title:"Wayang and the Federated AI",permalink:"/blog/wayang-federated-ai"},nextItem:{title:"Apache Kafka meets Wayang - Part 3",permalink:"/blog/kafka-meets-wayang-3"}},l={authorsImageUrls:[void 0]},p=[{value:"Expanding Apache Wayang&#39;s APIs",id:"expanding-apache-wayangs-apis",level:2},{value:"Defining WayangPlans in Python",id:"defining-wayangplans-in-python",level:2},{value:"Wayang-API-JSON",id:"wayang-api-json",level:2},{value:"Wrapping pipelines in MapPartition operators",id:"wrapping-pipelines-in-mappartition-operators",level:2},{value:"Coming soon",id:"coming-soon",level:2}];function c(n){const e={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:"In the vast landscape of data processing, efficiency and flexibility are\nimportant. However, navigating through a multitude of tools and\nlanguages often is a major inconvenience.\nApache Wayang's upcoming Python API will allow you to seamlessly\norchestrate data processing tasks without ever leaving the comfort\nof Python, irrespective of the underlying framework written in Java."}),"\n",(0,t.jsx)(e.h2,{id:"expanding-apache-wayangs-apis",children:"Expanding Apache Wayang's APIs"}),"\n",(0,t.jsx)(e.p,{children:"Apache Wayang's architecture decouples the process of planning from the\nresulting execution, allowing users to specify platform agnostic plans\nthrough the provided APIs."}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)("img",{width:"75%",alt:"wayang stack",src:"/img/architecture/wayang-stack.png"}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)(e.p,{children:["Python's popularity and convenience for data\nprocessing workloads makes it an obvious candidate for a desired API.\nPrevious APIs, such as the Scala API ",(0,t.jsx)(e.code,{children:"wayang-api-scala-java"})," benefited\nfrom the interoperability of Java and Scala that allows to reuse objects\nfrom other languages to provide new interfaces. Accessing JVM objects in\nPython is possible through several libraries, but in doing so,\nfuture APIs in other programming languages would need similar libraries and\nimplementations in order to exist. As a contrast to that, providing an\nAPI within Apache Wayang that receives input plans from any source and\nexecutes them within allows to create plans and submit them in any\nprogramming language. The following figure shows the architecture of ",(0,t.jsx)(e.code,{children:"pywayang"}),":"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)("img",{width:"75%",alt:"pywayang stack",src:"/img/architecture/pywayang.png"}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)(e.p,{children:["The Python API allows users to specify WayangPlans with UDFs in Python.\n",(0,t.jsx)(e.code,{children:"pywayang"})," then serializes the UDFs and constructs the WayangPlan in\nJSON format, preparing it to be sent to Apache Wayang's JSON API.\nWhen receiving a valid JSON plan, the JSON API uses the optimizer to\nconstruct an execution plan. However, since UDFs are defined in Python\nand thus need to be executed in Python as well, an operators function needs to be\nwrapped into a ",(0,t.jsx)(e.code,{children:"WrappedPythonFunction"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-scala",children:"val mapOperator = new MapPartitionsOperator[Input, Output](\n  new MapPartitionsDescriptor[Input, Output](\n    new WrappedPythonFunction[Input, Output](\n      ByteString.copyFromUtf8(udf)\n    ),\n    classOf[Input],\n    classOf[Output],\n  )\n)\n"})}),"\n",(0,t.jsxs)(e.p,{children:["This wrapped functional descriptor allows to handle execution of\nUDFs in Python through a socket connection with the ",(0,t.jsx)(e.code,{children:"pywayang"})," worker.\nInput data is sourced from the platform chosen by the optimizer and Apache\nWayang handles routing the output data to the next operator."]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(e.p,{children:"A new API in any programming languages would have\nto specify two things:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"A way to create plans that conform to a JSON format specified in the\nWayang JSON API."}),"\n",(0,t.jsxs)(e.li,{children:["A ",(0,t.jsx)(e.code,{children:"worker"})," that handles encoding and decoding of user defined\nfunctions (UDFs), as they need to\nbe executed on iterables in their respective language.\nAfter that, the API can be added as a module in Wayang, so that\noperators will be wrapped and UDFs can be executed in the desired\nprogramming language."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"defining-wayangplans-in-python",children:"Defining WayangPlans in Python"}),"\n",(0,t.jsxs)(e.p,{children:['As the "Hello World!" of data processing systems, wordcount will pose as\nour primary example to display how users can interact with Apache Wayang\nthrough the python package ',(0,t.jsx)(e.code,{children:"pywayang"}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from pywy.dataquanta import WayangContext\nfrom pywy.platforms.java import JavaPlugin\nfrom pywy.platforms.spark import SparkPlugin\n\ndef wordcount():\n    ctx = WayangContext() \\\n        .register({JavaPlugin, SparkPlugin}) \\\n        .textfile("file://README.md") \\\n        .flatmap(lambda w: w.split()) \\\n        .filter(lambda w: w.strip() != "") \\\n        .map(lambda w: (w.lower(), 1)) \\\n        .reduce_by_key(lambda t: t[0], lambda t1, t2: (t1[0], int(t1[1]) + int(t2[1]))) \\\n        .store_textfile("file:///wordcount-out-python.txt")\n\nif __name__ == "__main__":\n    wordcount()\n'})}),"\n",(0,t.jsxs)(e.p,{children:["The example displays a mode of operation that resembles the Scala\n",(0,t.jsx)(e.code,{children:"PlanBuilder"})," and the ",(0,t.jsx)(e.code,{children:"JavaPlanBuilder"}),". Plans are specified in a\nfunctional way, chaining operations until a terminal operation results\nin execution of the plan."]}),"\n",(0,t.jsx)(e.h2,{id:"wayang-api-json",children:"Wayang-API-JSON"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"wayang-api-json"})," module provides an executable that starts a REST\nserver. This server accepts a ",(0,t.jsx)(e.code,{children:"WayangPlan"})," in JSON format.\nStarting the REST API as a background process can be done by executing\nthe following:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-shell",children:"mvn clean package -pl :wayang-assembly -Pdistribution\ncd wayang-assembly/target/\ntar -xvf apache-wayang-assembly-0.7.1-SNAPSHOT-incubating-dist.tar.gz\ncd wayang-0.7.1-SNAPSHOT\n./bin/wayang-submit org.apache.wayang.api.json.Main &\n"})}),"\n",(0,t.jsx)(e.h2,{id:"wrapping-pipelines-in-mappartition-operators",children:"Wrapping pipelines in MapPartition operators"}),"\n",(0,t.jsxs)(e.p,{children:["With this architecture, the execution of an operator comes with an\nadditional overhead, because the UDFs will have to be executed in\npython. Python operators receive iterators through a socket and also\nreturn their result to Wayang through that connection. To minimize the\noverhead, unary operators that return unary results will be grouped in\npipelines. One pipeline of operators will be submitted to the Wayang\nJSON API as a single ",(0,t.jsx)(e.code,{children:"MapPartition"})," operator. This means that the UDFs\nspecified in this pipeline can be chained and only on call from Wayang\nto the Python worker will have to be made for a given pipeline."]}),"\n",(0,t.jsx)(e.h2,{id:"coming-soon",children:"Coming soon"}),"\n",(0,t.jsx)(e.p,{children:"As the Python API is currently in development and we are applying\nfinishing touches, this article serves as an outlook for what users can\nexpect to see soon."}),"\n",(0,t.jsxs)(e.p,{children:["Author: ",(0,t.jsx)(e.a,{href:"https://github.com/juripetersen",children:"juripetersen"})]})]})}function h(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},1151:(n,e,a)=>{a.d(e,{Z:()=>r,a:()=>s});var t=a(7294);const i={},o=t.createContext(i);function s(n){const e=t.useContext(o);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);